{"meta":{"title":"Sanwan","subtitle":null,"description":"我对普通的人类没有兴趣。你们之中要是有外星人、未来人、异世界人或者超能力者的话，就尽管来找我吧。","author":"三万","url":""},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-05-11T12:36:06.000Z","comments":false,"path":"about/index.html","permalink":"/about/index.html","excerpt":"","text":"[帅气の三万] 与&nbsp; 三万&nbsp; （ 0.0 ） 对话中... bot_ui_ini()","keywords":"关于"},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-05-05T09:09:22.000Z","comments":false,"path":"client/index.html","permalink":"/client/index.html","excerpt":"","text":"直接下载 or 扫码下载：","keywords":"Android客户端"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-05-05T09:09:22.000Z","comments":false,"path":"bangumi/index.html","permalink":"/bangumi/index.html","excerpt":"","text":"","keywords":null},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-05-11T02:28:18.000Z","comments":true,"path":"comment/index.html","permalink":"/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》","keywords":"留言板"},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-05-05T09:09:22.000Z","comments":false,"path":"donate/index.html","permalink":"/donate/index.html","excerpt":"","text":"","keywords":"谢谢饲主了喵~"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-05-05T09:09:22.000Z","comments":false,"path":"lab/index.html","permalink":"/lab/index.html","excerpt":"","text":"sakura主题balabala","keywords":"Lab实验室"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-05-05T09:09:22.000Z","comments":true,"path":"links/index.html","permalink":"/links/index.html","excerpt":"","text":"","keywords":"友人帐"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-07-24T09:21:16.239Z","comments":false,"path":"music/index.html","permalink":"/music/index.html","excerpt":"","text":"","keywords":"喜欢的音乐"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-05-05T09:09:22.000Z","comments":true,"path":"rss/index.html","permalink":"/rss/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-05-05T09:09:22.000Z","comments":true,"path":"tags/index.html","permalink":"/tags/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-05-05T09:09:22.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro","keywords":"Hexo 主题 Sakura 🌸"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-05-05T09:09:22.000Z","comments":false,"path":"video/index.html","permalink":"/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }","keywords":"B站"}],"posts":[{"title":"letcode67二叉树的最近公共祖先","slug":"二叉树的最近公共祖先","date":"2020-08-04T01:17:00.000Z","updated":"2020-08-04T01:53:51.865Z","comments":true,"path":"二叉树的最近公共祖先/","link":"","permalink":"/二叉树的最近公共祖先/","excerpt":"","text":"I. 二叉搜索树的最近公共祖先给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root.val&lt;p.val&amp;&amp;root.val&lt;q.val)return lowestCommonAncestor(root.right,p,q); if(root.val&gt;p.val&amp;&amp;root.val&gt;q.val)return lowestCommonAncestor(root.left,p,q); return root; } } 根据以上定义，若root是p,q的最近公共祖先则只可能为以下情况之一： p和 q 在 root 的子树中，且分列 root 的 异侧（即分别在左、右子树中）； p=root，且 q 在 root 的左或右子树中； q=root，且 p 在 root的左或右子树中； 递推工作： 当 p,q都在root的右子树中则开启递归 root.right并返回； 否则,当p,q都在root的左子树中，则开启递归 root.left并返回； 返回值： 最近公共祖先 rootrootroot 。 复杂度分析： 时间复杂度 O(N)： 其中N为二叉树节点数；每循环一轮排除一层，二叉搜索树的层数最小为 log⁡N（满二叉树），最大为 N（退化为链表）。 空间复杂度O(N)：最差情况下，即树退化为链表时，递归深度达到树的层数 N。 II. 二叉树的最近公共祖先给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null) return null; // 如果树为空，直接返回null if(root == p || root == q) return root; // 如果 p和q中有等于 root的，那么它们的最近公共祖先即为root（一个节点也可以是它自己的祖先） TreeNode left = lowestCommonAncestor(root.left, p, q); // 递归遍历左子树，只要在左子树中找到了p或q，则先找到谁就返回谁 TreeNode right = lowestCommonAncestor(root.right, p, q); // 递归遍历右子树，只要在右子树中找到了p或q，则先找到谁就返回谁 if(left == null) return right; // 如果在左子树中 p和 q都找不到，则 p和 q一定都在右子树中，右子树中先遍历到的那个就是最近公共祖先（一个节点也可以是它自己的祖先） else if(right == null) return left; // 否则，如果 left不为空，在左子树中有找到节点（p或q），这时候要再判断一下右子树中的情况，如果在右子树中，p和q都找不到，则 p和q一定都在左子树中，左子树中先遍历到的那个就是最近公共祖先（一个节点也可以是它自己的祖先） else return root; //否则，当 left和 right均不为空时，说明 p、q节点分别在 root异侧, 最近公共祖先即为 root } } 递归解析： 终止条件： 当越过叶节点，则直接返回 null ； 当 root 等于 p,q ，则直接返回root； 递推工作： 开启递归左子节点，返回值记为 left ； 开启递归右子节点，返回值记为 right ； 返回值:根据 left和 right ，可展开为四种情况； 1.当 left 和 right 同时为空 ：说明 root 的左/右子树中都不包含 p,q ，返回 null； 2.当 left 和 right 同时不为空 ：说明 p,q 分列在 root的 异侧（分别在 左 / 右子树），因此 root为最近公共祖先，返回 root ； 3.当 left 为空 ，right不为空 ：p,q 都不在 root 的左子树中，直接返回 right。具体可分为两种情况： p,q 其中一个在 root 的右子树中，此时right指向 p（假设为p）； p,q 两节点都在 root 的右子树中，此时的right指向最近公共祖先节点 ； 4.当 left为空，right为空 ：与情况3.同理；","categories":[{"name":"数据结构","slug":"数据结构","permalink":"/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"/categories/数据结构/"}]},{"title":"@Configuration与@Bean注解的原理","slug":"8-4","date":"2020-08-04T00:55:00.000Z","updated":"2020-08-04T01:14:22.472Z","comments":true,"path":"8-4/","link":"","permalink":"/8-4/","excerpt":"","text":"作用 @Configuration与@Bean结合使用。 @Configuration可理解为用spring的时候xml里面的标签，@Bean可理解为用spring的时候xml里面的标签。Spring Boot不是spring的加强版，所以@Configuration和@Bean同样可以用在普通的spring项目中，而不是Spring Boot特有的，只是在spring用的时候，注意加上扫包配置。 bean的作用 Bean注解的作用之一就是能够管理第三方jar包内的类到容器中。 比如我们引入一个第三方的jar包，这其中的某个类，StringUtil需要注入到我们的IndexService类中，因为我们没有源码，不能再StringUtil中增加@Component或者@Service注解。这时候我们可以通过使用@Bean的方式，把这个类交到Spring容器进行管理，最终就能够被注入到IndexService实例中。 Configuration 在@Configuration中被@Bean标记的方法，会被Spring进行CGLIB代理，从而进行增强。@SpringBootApplication注解相当于使用@Configuration、@EnableAutoConfiguration和@ComponentScan的默认属性@ComponentScan默认为当前包与其子包。 过程 SpringBoot中的Spring容器在启动的时候，会扫描当前包与子包中所有实现@Component注解或者其子类如@Configuration(找个本质上还是@Component)标记的类，认为这些类是bean, 并且把这些bean对应的beanDefinition放到容器中进行管理。BeanDefinition是对bean的描述，里边存有bean的名称，Class等基本信息。 在获取到所有的bean defenition之后，Spring会有一些post process执行，其中一个就是ConfigurationClassPostProcessor， 在这里，Spring会遍历所有的bean definition， 如果发现其中有标记了@Configuration注解的，会对这个类进行CGLIB代码，生成一个代理的类，并且把这个类设置到BeanDefenition的Class属性中。当需要拿到这个bean的实例的时候，会从这个class属性中拿到的Class对象进行反射，那么最终反射出来的是代理增强后的类。 代理中对方法进行了增强？在哪方面进行了增强？对于@Bean标记的方法，返回的都是一个bean，在增强的方法中，Spring会先去容器中查看一下是否有这个bean的实例了，如果有了的话，就返回已有对象，没有的话就创建一个，然后放到容器中。 在执行getBean(IndexService.class)对应的bean的时候，会调用indexService()方法，而因为现在我们是在CGLIB增强的类中，indexService()方法已经被增强，Spring会先查看Spring容器中有没有实例，此时还没有，就new一个IndexService实例放到容器中。 在执行getBean(OrderService.class)的时候，会调用orderService()方法，这里会调用indexService()方法，因为现在是在增强的类中，所以此处调用的也是增强的indexService()方法，会先去容器中查看有没有实例。现在已经有实例了，就会直接返回这个实例，不再新创建。 @Bean注解可以对第三方的某些托管给Spring容器的工具类进行定制化。在传统配置文件方式的时候，我们需要定制某个bean的属性，我们会使用这些bean，既可以是我们的实体类，也可以是某些工具类的配置文件对应的类。比如说RestTemplate.在我们获取RestTemplate对应的实例的时候，初始化这个实例的时候，会在容器中寻找配置文件对应的类，如果有的话则注入到这个类中。那么RestTemplate实例对应的各种参数，比如说timeout时间长度等，就全部定制好了。使用@Bean注解，同样也是达到这种目的。不过这个是在扫描的时候把bean放入到容器中，而不是读取配置文件。前提是RestTemplate内部定义了这种兼容性的设计，即内部有地方接收这些注入的参数，并且把这些参数合理转化到相应的属性中。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"letcode 65 不用加减乘除做加法","slug":"letcode-65-不用加减乘除做加法","date":"2020-07-24T06:16:00.000Z","updated":"2020-07-24T08:12:57.859Z","comments":true,"path":"letcode-65-不用加减乘除做加法/","link":"","permalink":"/letcode-65-不用加减乘除做加法/","excerpt":"","text":"题目描述写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 思路 通过a&amp;b之后左移一位算出进位 即a&amp;b&lt;&lt;1 可以得到进位 通过a^b得到非进位的和 class Solution { public int add(int a, int b) { while(b!=0){//进位为0停滞循环 int c=(a&amp;b)&lt;&lt;1;//进位 a^=b;//非进位和 b=c; } return a; } } 感觉跟以前学的微机原理很像！","categories":[{"name":"数据结构","slug":"数据结构","permalink":"/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"/categories/数据结构/"}]},{"title":"Jquery03","slug":"Jquery3","date":"2020-07-24T05:49:00.000Z","updated":"2020-07-24T05:56:15.145Z","comments":true,"path":"Jquery3/","link":"","permalink":"/Jquery3/","excerpt":"","text":"1.1. jQuery 事件注册​ jQuery 为我们提供了方便的事件注册机制，是开发人员抑郁操作优缺点如下： 优点: 操作简单，且不用担心事件覆盖等问题。 缺点: 普通的事件注册不能做事件委托，且无法实现事件解绑，需要借助其他方法。 语法 演示代码 &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { // 1. 单个事件注册 $(&quot;div&quot;).click(function() { $(this).css(&quot;background&quot;, &quot;purple&quot;); }); $(&quot;div&quot;).mouseenter(function() { $(this).css(&quot;background&quot;, &quot;skyblue&quot;); }); }) &lt;/script&gt; &lt;/body&gt; 1.2. jQuery 事件处理​ 因为普通注册事件方法的不足，jQuery又开发了多个处理方法 on(): 用于事件绑定，目前最好用的事件绑定方法 off(): 事件解绑 trigger() / triggerHandler(): 事件触发 1.2.1 事件处理 on() 绑定事件​ 因为普通注册事件方法的不足，jQuery又创建了多个新的事件绑定方法bind() / live() / delegate() / on()等，其中最好用的是: on() 语法 演示代码 &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;ul&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt;&lt;/ol&gt; &lt;script&gt; $(function() { // (1) on可以绑定1个或者多个事件处理程序 // $(&quot;div&quot;).on({ // mouseenter: function() { // $(this).css(&quot;background&quot;, &quot;skyblue&quot;); // }, // click: function() { // $(this).css(&quot;background&quot;, &quot;purple&quot;); // } // }); $(&quot;div&quot;).on(&quot;mouseenter mouseleave&quot;, function() { $(this).toggleClass(&quot;current&quot;); }); // (2) on可以实现事件委托（委派） // click 是绑定在ul 身上的，但是 触发的对象是 ul 里面的小li // $(&quot;ul li&quot;).click(); $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() { alert(11); }); // (3) on可以给未来动态创建的元素绑定事件 $(&quot;ol&quot;).on(&quot;click&quot;, &quot;li&quot;, function() { alert(11); }) var li = $(&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;); $(&quot;ol&quot;).append(li); }) &lt;/script&gt; &lt;/body&gt; 1.2.2. 事件处理 off() 解绑事件​ 当某个事件上面的逻辑，在特定需求下不需要的时候，可以把该事件上的逻辑移除，这个过程我们称为事件解绑。jQuery 为我们提供 了多种事件解绑方法：die() / undelegate() / off() 等 语法 演示代码 &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;ul&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;li&gt;我们都是好孩子&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;我是一个P标签&lt;/p&gt; &lt;script&gt; $(function() { // 事件绑定 $(&quot;div&quot;).on({ click: function() { console.log(&quot;我点击了&quot;); }, mouseover: function() { console.log(&#39;我鼠标经过了&#39;); } }); $(&quot;ul&quot;).on(&quot;click&quot;, &quot;li&quot;, function() { alert(11); }); // 1. 事件解绑 off // $(&quot;div&quot;).off(); // 这个是解除了div身上的所有事件 $(&quot;div&quot;).off(&quot;click&quot;); // 这个是解除了div身上的点击事件 $(&quot;ul&quot;).off(&quot;click&quot;, &quot;li&quot;); // 2. one() 但是它只能触发事件一次 $(&quot;p&quot;).one(&quot;click&quot;, function() { alert(11); }) }) &lt;/script&gt; &lt;/body&gt; 1.2.3. 事件处理 trigger() 自动触发事件​ 有些时候，在某些特定的条件下，我们希望某些事件能够自动触发, 比如轮播图自动播放功能跟点击右侧按钮一致。可以利用定时器自动触发右侧按钮点击事件，不必鼠标点击触发。由此 jQuery 为我们提供了两个自动触发事件 trigger() 和 triggerHandler() ; 语法 演示代码 &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;input type=&quot;text&quot;&gt; &lt;script&gt; $(function() { // 绑定事件 $(&quot;div&quot;).on(&quot;click&quot;, function() { alert(11); }); // 自动触发事件 // 1. 元素.事件() // $(&quot;div&quot;).click();会触发元素的默认行为 // 2. 元素.trigger(&quot;事件&quot;) // $(&quot;div&quot;).trigger(&quot;click&quot;);会触发元素的默认行为 $(&quot;input&quot;).trigger(&quot;focus&quot;); // 3. 元素.triggerHandler(&quot;事件&quot;) 就是不会触发元素的默认行为 $(&quot;input&quot;).on(&quot;focus&quot;, function() { $(this).val(&quot;你好吗&quot;); }); // 一个会获取焦点，一个不会 $(&quot;div&quot;).triggerHandler(&quot;click&quot;); // $(&quot;input&quot;).triggerHandler(&quot;focus&quot;); }); &lt;/script&gt; &lt;/body&gt; 1.3. jQuery 事件对象​ jQuery 对DOM中的事件对象 event 进行了封装，兼容性更好，获取更方便，使用变化不大。事件被触发，就会有事件对象的产生。 语法 演示代码 &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { $(document).on(&quot;click&quot;, function() { console.log(&quot;点击了document&quot;); }) $(&quot;div&quot;).on(&quot;click&quot;, function(event) { // console.log(event); console.log(&quot;点击了div&quot;); event.stopPropagation(); }) }) &lt;/script&gt; &lt;/body&gt; 注意：jQuery中的 event 对象使用，可以借鉴 API 和 DOM 中的 event 。 1.4. jQuery 拷贝对象​ jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。 语法 演示代码 &lt;script&gt; $(function() { // 1.合并数据 var targetObj = {}; var obj = { id: 1, name: &quot;andy&quot; }; // $.extend(target, obj); $.extend(targetObj, obj); console.log(targetObj); // 2. 会覆盖 targetObj 里面原来的数据 var targetObj = { id: 0 }; var obj = { id: 1, name: &quot;andy&quot; }; // $.extend(target, obj); $.extend(targetObj, obj); console.log(targetObj); }) &lt;/script&gt; 1.5. jQuery 多库共存​ 实际开发中，很多项目连续开发十多年，jQuery版本不断更新，最初的 jQuery 版本无法满足需求，这时就需要保证在旧有版本正常运行的情况下，新的功能使用新的jQuery版本实现，这种情况被称为，jQuery 多库共存。 语法 演示代码 &lt;script&gt; $(function() { // 让jquery 释放对$ 控制权 让用自己决定 var suibian = jQuery.noConflict(); console.log(suibian(&quot;span&quot;)); }) &lt;/script&gt; 1.6. jQuery 插件​ jQuery 功能比较有限，想要更复杂的特效效果，可以借助于 jQuery 插件完成。 这些插件也是依赖于jQuery来完成的，所以必须要先引入 jQuery文件，因此也称为 jQuery 插件。 ​ jQuery 插件常用的网站： jQuery 插件库 http://www.jq22.com/ jQuery 之家 http://www.htmleaf.com/ jQuery 插件使用步骤： 引入相关文件。（jQuery 文件 和 插件文件） 复制相关html、css、js (调用插件)。 1.6.1. 瀑布流插件下载位置 代码演示 ​ 插件的使用三点： 1. 引入css. 2.引入JS 3.引入html。 （有的简单插件只需引入html和js，甚至有的只需引入js） 1.引入css. &lt;link rel=&quot;stylesheet&quot; href=&quot;css/normalize.css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/default.css&quot;&gt; &lt;!-- 下面的样式代码为页面布局，可以引入，也可以自己写，自己设计页面样式，一般为直接引入，方便 --&gt; &lt;style type=&quot;text/css&quot;&gt; #gallery-wrapper { position: relative; max-width: 75%; width: 75%; margin: 50px auto; } img.thumb { width: 100%; max-width: 100%; height: auto; } .white-panel { position: absolute; background: white; border-radius: 5px; box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.3); padding: 10px; } .white-panel h1 { font-size: 1em; } .white-panel h1 a { color: #A92733; } .white-panel:hover { box-shadow: 1px 1px 10px rgba(0, 0, 0, 0.5); margin-top: -5px; -webkit-transition: all 0.3s ease-in-out; -moz-transition: all 0.3s ease-in-out; -o-transition: all 0.3s ease-in-out; transition: all 0.3s ease-in-out; } &lt;/style&gt; 2.引入js. &lt;!-- 前两个必须引入 --&gt; &lt;script src=&quot;js/jquery-1.11.0.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/pinterest_grid.js&quot;&gt;&lt;/script&gt; &lt;!-- 下面的为启动瀑布流代码，参数可调节属性，具体功能可参考readme.html --&gt; &lt;script type=&quot;text/javascript&quot;&gt; $(function() { $(&quot;#gallery-wrapper&quot;).pinterest_grid({ no_columns: 5, padding_x: 15, padding_y: 10, margin_bottom: 50, single_column_breakpoint: 700 }); }); &lt;/script&gt; 3.引入html. &lt;!-- html结构一般为事先写好，很难修改结构，但可以修改内容及图片的多少（article标签） --&gt; &lt;section id=&quot;gallery-wrapper&quot;&gt; &lt;article class=&quot;white-panel&quot;&gt; &lt;img src=&quot;images/P_000.jpg&quot; class=&quot;thumb&quot;&gt; &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;里面很精彩哦&lt;/p&gt; &lt;/article&gt; &lt;article class=&quot;white-panel&quot;&gt; &lt;img src=&quot;images/P_005.jpg&quot; class=&quot;thumb&quot;&gt; &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;里面很精彩哦&lt;/p&gt; &lt;/article&gt; &lt;article class=&quot;white-panel&quot;&gt; &lt;img src=&quot;images/P_006.jpg&quot; class=&quot;thumb&quot;&gt; &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;里面很精彩哦&lt;/p&gt; &lt;/article&gt; &lt;article class=&quot;white-panel&quot;&gt; &lt;img src=&quot;images/P_007.jpg&quot; class=&quot;thumb&quot;&gt; &lt;h1&gt;&lt;a href=&quot;#&quot;&gt;我是轮播图片1&lt;/a&gt;&lt;/h1&gt; &lt;p&gt;里面很精彩哦&lt;/p&gt; &lt;/article&gt; &lt;/section&gt; 总结：jQuery插件就是引入别人写好的：html 、css、js （有时也可以只引入一部分，读懂后也可以修改部分内容） 1.6.2. 图片懒加载插件​ 图片的懒加载就是：当页面滑动到有图片的位置，图片才进行加载，用以提升页面打开的速度及用户体验。 代码演示 ​ 懒加载只需引入html 和 js操作 即可，此插件不涉及css。 1.引入js &lt;script src=&quot;js/EasyLazyload.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; lazyLoadInit({ showTime: 1100, onLoadBackEnd: function(i, e) { console.log(&quot;onLoadBackEnd:&quot; + i); }, onLoadBackStart: function(i, e) { console.log(&quot;onLoadBackStart:&quot; + i); } }); &lt;/script&gt; 2.引入html &lt;img data-lazy-src=&quot;upload/floor-1-3.png&quot; alt=&quot;&quot;&gt; 1.6.3. 全屏滚动插件​ 全屏滚动插件比较大，所以，一般大型插件都会有帮助文档，或者网站。全屏滚动插件介绍比较详细的网站为： http://www.dowebok.com/demo/2014/77/ 代码演示 ​ 全屏滚动因为有多重形式，所以不一样的风格html和css也不一样，但是 js 变化不大。所以下面只演示js的引入，html和css引入根据自己实际 项目需要使用哪种风格引入对应的HTML和CSS。 &lt;script src=&quot;js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/fullpage.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $(function() { $(&#39;#dowebok&#39;).fullpage({ sectionsColor: [&#39;pink&#39;, &#39;#4BBFC3&#39;, &#39;#7BAABE&#39;, &#39;#f90&#39;], navigation: true }); }); &lt;/script&gt; 注意：实际开发，一般复制文件，然后在文件中进行修改和添加功能。 1.6.4. bootstrap组件代码演示 引入bootstrap相关css和js &lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;bootstrap/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 去官网复制html的功能模块 &lt;div class=&quot;container&quot;&gt; &lt;!-- Single button --&gt; &lt;div class=&quot;btn-group&quot;&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-default dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; Action &lt;span class=&quot;caret&quot;&gt;&lt;/span&gt; &lt;/button&gt; &lt;ul class=&quot;dropdown-menu&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Another action&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Something else here&lt;/a&gt;&lt;/li&gt; &lt;li role=&quot;separator&quot; class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Separated link&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; 1.6.5. bootstrap插件（JS）​ bootstrap中的js插件其实也是组件的一部分，只不过是需要js调用功能的组件，所以一般bootstrap的js插件一般会伴随着js代码（有的也可以 省略js，用属性实现）。 ​ 步骤： 1.引入bootstrap相关css和js 2.去官网复制html 3.复制js代码，启动js插件。 代码演示 引入bootstrap相关css和js &lt;link rel=&quot;stylesheet&quot; href=&quot;bootstrap/css/bootstrap.min.css&quot;&gt; &lt;script src=&quot;bootstrap/js/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;bootstrap/js/bootstrap.min.js&quot;&gt;&lt;/script&gt; 去官网复制html的功能模块 &lt;!-- 模态框 --&gt; &lt;!-- Large modal --&gt; &lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; data-toggle=&quot;modal&quot; data-target=&quot;.bs-example-modal-lg&quot;&gt;Large modal&lt;/button&gt; &lt;div class=&quot;modal fade bs-example-modal-lg&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myLargeModalLabel&quot;&gt; &lt;div class=&quot;modal-dialog modal-lg&quot; role=&quot;document&quot;&gt; &lt;div class=&quot;modal-content&quot;&gt; 里面就是模态框 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 复制js代码，启动js插件。 &lt;script&gt; // 当我们点击了自己定义的按钮，就弹出模态框 $(&quot;.myBtn&quot;).on(&quot;click&quot;, function() { // alert(11); $(&#39;#btn&#39;).modal() }) &lt;/script&gt;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}]},{"title":"Jquery02","slug":"Jquery2","date":"2020-07-24T05:41:00.000Z","updated":"2020-07-24T05:46:47.330Z","comments":true,"path":"Jquery2/","link":"","permalink":"/Jquery2/","excerpt":"","text":"1.1. jQuery 属性操作​ jQuery 常用属性操作有三种：prop() / attr() / data() ; 1.1.1 元素固有属性值 prop()​ 所谓元素固有属性就是元素本身自带的属性，比如 元素里面的 href ，比如 元素里面的 type。 语法 ​ 注意：prop() 除了普通属性操作，更适合操作表单属性：disabled / checked / selected 等。 1.1.2 元素自定义属性值 attr()​ 用户自己给元素添加的属性，我们称为自定义属性。 比如给 div 添加 index =“1”。 语法 ​ 注意：attr() 除了普通属性操作，更适合操作自定义属性。（该方法也可以获取 H5 自定义属性） 1.1.3 数据缓存 data()​ data() 方法可以在指定的元素上存取数据，并不会修改 DOM 元素结构。一旦页面刷新，之前存放的数据都将被移除。 语法 ​ 注意：同时，还可以读取 HTML5 自定义属性 data-index ，得到的是数字型。 演示代码 &lt;body&gt; &lt;a href=&quot;http://www.itcast.cn&quot; title=&quot;都挺好&quot;&gt;都挺好&lt;/a&gt; &lt;input type=&quot;checkbox&quot; name=&quot;&quot; id=&quot;&quot; checked&gt; &lt;div index=&quot;1&quot; data-index=&quot;2&quot;&gt;我是div&lt;/div&gt; &lt;span&gt;123&lt;/span&gt; &lt;script&gt; $(function() { //1. element.prop(&quot;属性名&quot;) 获取元素固有的属性值 console.log($(&quot;a&quot;).prop(&quot;href&quot;)); $(&quot;a&quot;).prop(&quot;title&quot;, &quot;我们都挺好&quot;); $(&quot;input&quot;).change(function() { console.log($(this).prop(&quot;checked&quot;)); }); // console.log($(&quot;div&quot;).prop(&quot;index&quot;)); // 2. 元素的自定义属性 我们通过 attr() console.log($(&quot;div&quot;).attr(&quot;index&quot;)); $(&quot;div&quot;).attr(&quot;index&quot;, 4); console.log($(&quot;div&quot;).attr(&quot;data-index&quot;)); // 3. 数据缓存 data() 这个里面的数据是存放在元素的内存里面 $(&quot;span&quot;).data(&quot;uname&quot;, &quot;andy&quot;); console.log($(&quot;span&quot;).data(&quot;uname&quot;)); // 这个方法获取data-index h5自定义属性 第一个 不用写data- 而且返回的是数字型 console.log($(&quot;div&quot;).data(&quot;index&quot;)); }) &lt;/script&gt; &lt;/body&gt; 1.2. jQuery 文本属性值​ jQuery的文本属性值常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性。 1.2.1 jQuery内容文本值​ 常见操作有三种：html() / text() / val() ; 分别对应JS中的 innerHTML 、innerText 和 value 属性，主要针对元素的内容还有表单的值操作。 语法 ​ 注意：html() 可识别标签，text() 不识别标签。 演示代码 &lt;body&gt; &lt;div&gt; &lt;span&gt;我是内容&lt;/span&gt; &lt;/div&gt; &lt;input type=&quot;text&quot; value=&quot;请输入内容&quot;&gt; &lt;script&gt; // 1. 获取设置元素内容 html() console.log($(&quot;div&quot;).html()); // $(&quot;div&quot;).html(&quot;123&quot;); // 2. 获取设置元素文本内容 text() console.log($(&quot;div&quot;).text()); $(&quot;div&quot;).text(&quot;123&quot;); // 3. 获取设置表单值 val() console.log($(&quot;input&quot;).val()); $(&quot;input&quot;).val(&quot;123&quot;); &lt;/script&gt; &lt;/body&gt; 1.3. jQuery 元素操作​ jQuery 元素操作主要讲的是用jQuery方法，操作标签的遍历、创建、添加、删除等操作。 1.3.1. 遍历元素​ jQuery 隐式迭代是对同一类元素做了同样的操作。 如果想要给同一类元素做不同操作，就需要用到遍历。 语法1 ​ 注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。 语法2 ​ 注意：此方法用于遍历 jQuery 对象中的每一项，回调函数中元素为 DOM 对象，想要使用 jQuery 方法需要转换。 演示代码 &lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;div&gt;2&lt;/div&gt; &lt;div&gt;3&lt;/div&gt; &lt;script&gt; $(function() { // 如果针对于同一类元素做不同操作，需要用到遍历元素（类似for，但是比for强大） var sum = 0; var arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]; // 1. each() 方法遍历元素 $(&quot;div&quot;).each(function(i, domEle) { // 回调函数第一个参数一定是索引号 可以自己指定索引号号名称 // console.log(i); // 回调函数第二个参数一定是 dom 元素对象，也是自己命名 // console.log(domEle); // 使用jQuery方法需要转换 $(domEle) $(domEle).css(&quot;color&quot;, arr[i]); sum += parseInt($(domEle).text()); }) console.log(sum); // 2. $.each() 方法遍历元素 主要用于遍历数据，处理数据 // $.each($(&quot;div&quot;), function(i, ele) { // console.log(i); // console.log(ele); // }); // $.each(arr, function(i, ele) { // console.log(i); // console.log(ele); // }) $.each({ name: &quot;andy&quot;, age: 18 }, function(i, ele) { console.log(i); // 输出的是 name age 属性名 console.log(ele); // 输出的是 andy 18 属性值 }) }) &lt;/script&gt; &lt;/body&gt; 1.3.3. 创建、添加、删除​ jQuery方法操作元素的创建、添加、删除方法很多，则重点使用部分，如下： 语法总和 ​ 注意：以上只是元素的创建、添加、删除方法的常用方法，其他方法请参详API。 案例代码 &lt;body&gt; &lt;ul&gt; &lt;li&gt;原先的li&lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;test&quot;&gt;我是原先的div&lt;/div&gt; &lt;script&gt; $(function() { // 1. 创建元素 var li = $(&quot;&lt;li&gt;我是后来创建的li&lt;/li&gt;&quot;); // 2. 添加元素 // 2.1 内部添加 // $(&quot;ul&quot;).append(li); 内部添加并且放到内容的最后面 $(&quot;ul&quot;).prepend(li); // 内部添加并且放到内容的最前面 // 2.2 外部添加 var div = $(&quot;&lt;div&gt;我是后妈生的&lt;/div&gt;&quot;); // $(&quot;.test&quot;).after(div); $(&quot;.test&quot;).before(div); // 3. 删除元素 // $(&quot;ul&quot;).remove(); 可以删除匹配的元素 自杀 // $(&quot;ul&quot;).empty(); // 可以删除匹配的元素里面的子节点 孩子 $(&quot;ul&quot;).html(&quot;&quot;); // 可以删除匹配的元素里面的子节点 孩子 }) &lt;/script&gt; &lt;/body&gt; 1.4. jQuery 尺寸、位置操作​ jQuery中分别为我们提供了两套快速获取和设置元素尺寸和位置的API，方便易用，内容如下。 1.4.1. jQuery 尺寸操作​ jQuery 尺寸操作包括元素宽高的获取和设置，且不一样的API对应不一样的盒子模型。 语法 代码演示 &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { // 1. width() / height() 获取设置元素 width和height大小 console.log($(&quot;div&quot;).width()); // $(&quot;div&quot;).width(300); // 2. innerWidth() / innerHeight() 获取设置元素 width和height + padding 大小 console.log($(&quot;div&quot;).innerWidth()); // 3. outerWidth() / outerHeight() 获取设置元素 width和height + padding + border 大小 console.log($(&quot;div&quot;).outerWidth()); // 4. outerWidth(true) / outerHeight(true) 获取设置 width和height + padding + border + margin console.log($(&quot;div&quot;).outerWidth(true)); }) &lt;/script&gt; &lt;/body&gt; ​ 注意：有了这套 API 我们将可以快速获取和子的宽高，至于其他属性想要获取和设置，还要使用 css() 等方法配合。 1.4.2. jQuery 位置操作​ jQuery的位置操作主要有三个： offset()、position()、scrollTop()/scrollLeft() , 具体介绍如下: 语法 代码演示 &lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;back&quot;&gt;返回顶部&lt;/div&gt; &lt;div class=&quot;container&quot;&gt;&lt;/div&gt; &lt;script&gt; $(function() { // 1. 获取设置距离文档的位置（偏移） offset console.log($(&quot;.son&quot;).offset()); console.log($(&quot;.son&quot;).offset().top); // $(&quot;.son&quot;).offset({ // top: 200, // left: 200 // }); // 2. 获取距离带有定位父级位置（偏移） position 如果没有带有定位的父级，则以文档为准 // 这个方法只能获取不能设置偏移 console.log($(&quot;.son&quot;).position()); // $(&quot;.son&quot;).position({ // top: 200, // left: 200 // }); // 3. 被卷去的头部 $(document).scrollTop(100); // 被卷去的头部 scrollTop() / 被卷去的左侧 scrollLeft() // 页面滚动事件 var boxTop = $(&quot;.container&quot;).offset().top; $(window).scroll(function() { // console.log(11); console.log($(document).scrollTop()); if ($(document).scrollTop() &gt;= boxTop) { $(&quot;.back&quot;).fadeIn(); } else { $(&quot;.back&quot;).fadeOut(); } }); // 返回顶部 $(&quot;.back&quot;).click(function() { // $(document).scrollTop(0); $(&quot;body, html&quot;).stop().animate({ scrollTop: 0 }); // $(document).stop().animate({ // scrollTop: 0 // }); 不能是文档而是 html和body元素做动画 }) }) &lt;/script&gt; &lt;/body&gt;","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"关于git提交方面的报错","slug":"关于git提交方面的报错","date":"2020-07-24T03:12:00.000Z","updated":"2020-07-24T03:19:58.847Z","comments":true,"path":"关于git提交方面的报错/","link":"","permalink":"/关于git提交方面的报错/","excerpt":"","text":"今天在公司搭hexo环境，发现了hexo d的时候一直报错，差了很多相关的资料发现是公钥的问题，以下是解决方案 只适用于只有一个git环境 如果你的电脑只有一个git环境，那么极大多数情况是由于 GitHub 账号没有设置 ssh 公钥信息所致。 前往 GitHub 网站的”account settings”依次点击”Setting -&gt; SSH Keys”-&gt;”New SSH key”Title处填写“id_rsa.pub”或其他任意信息。 key处原样拷贝下面命令的打印 ~/.ssh/id_rsa.pub 文件的内容： cat ~/.ssh/id_rsa.pub # 控制台上输出内容 pbcopy &lt; ~/.ssh/id_rsa.pub # 自动拷贝到粘贴板 如没有则按下述方法生成： ssh-keygen -t rsa输入文件名的地方输入可以输入自定义文件名，默认是id_rsa，然后一路回车…… 注意如果自定义文件名的话，需要加一个config文件，下文有介绍。最后，输入ssh -T git@github.com如果没有报错，再尝试输出就应该有了 cat ~/.ssh/id_rsa.pub # 控制台上输出内容 pbcopy &lt; ~/.ssh/id_rsa.pub # 自动拷贝到粘贴板","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"Jquery01","slug":"Jquery","date":"2020-07-24T00:49:00.000Z","updated":"2020-07-24T05:58:01.605Z","comments":true,"path":"Jquery/","link":"","permalink":"/Jquery/","excerpt":"","text":"来公司实习摸鱼了一周了，最近组长给我分配了个任务让我写h5的页面，前段相关的内容没怎么深入了解，最近在看jquery的视频，记录下相关笔记。 1.1. jQuery 介绍1.1.1 JavaScript 库​ JavaScript库：即 library，是一个封装好的特定的集合（方法和函数）。从封装一大堆函数的角度理解库，就是在这个库中，封装了很多预先定义好的函数在里面，比如动画animate、hide、show，比如获取元素等。 简单理解： 就是一个JS 文件，里面对我们原生js代码进行了封装，存放到里面。这样我们可以快速高效的使用这些封装好的功能了。 比如 jQuery，就是为了快速方便的操作DOM，里面基本都是函数（方法）。 ​ 常见的JavaScript 库：jQuery、Prototype、YUI、Dojo、Ext JS、移动端的zepto等，这些库都是对原生 JavaScript 的封装，内部都是用 JavaScript 实现的 1.1.2 jQuery的概念​ jQuery总体概况如下 : jQuery 是一个快速、简洁的 JavaScript 库，其设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。 j 就是 JavaScript； Query 查询； 意思就是查询js，把js中的DOM操作做了封装，我们可以快速的查询使用里面的功能。 jQuery 封装了 JavaScript 常用的功能代码，优化了 DOM 操作、事件处理、动画设计和 Ajax 交互。 学习jQuery本质： 就是学习调用这些函数（方法）。 jQuery 出现的目的是加快前端人员的开发速度，我们可以非常方便的调用和使用它，从而提高开发效率。 1.2. jQuery 的基本使用1.2.1 jQuery 的下载​ jQuery的官网地址： https://jquery.com/，官网即可下载最新版本。 各个版本的下载：https://code.jquery.com/ ​ 版本介绍： 1x ：兼容 IE 678 等低版本浏览器， 官网不再更新 2x ：不兼容 IE 678 等低版本浏览器， 官网不再更新 3x ：不兼容 IE 678 等低版本浏览器， 是官方主要更新维护的版本 1.2.2. 体验jQuery​ 步骤： 引入jQuery文件。 在文档最末尾插入 script 标签，书写体验代码。 $(‘div’).hide() 可以隐藏盒子。 1.2.3. jQuery的入口函数​ jQuery中常见的两种入口函数： // 第一种: 简单易用。 $(function () { ... // 此处是页面 DOM 加载完成的入口 }) ; // 第二种: 繁琐，但是也可以实现 $(document).ready(function(){ ... // 此处是页面DOM加载完成的入口 }); ​ 总结： 等着 DOM 结构渲染完毕即可执行内部代码，不必等到所有外部资源加载完成，jQuery 帮我们完成了封装。 相当于原生 js 中的 DOMContentLoaded。 不同于原生 js 中的 load 事件是等页面文档、外部的 js 文件、css文件、图片加载完毕才执行内部代码。 更推荐使用第一种方式。 1.2.4. jQuery中的顶级对象$ \\$是 jQuery 的别称，在代码中可以使用 jQuery 代替，但一般为了方便，通常都直接使用 $ 。 \\$是jQuery的顶级对象，相当于原生JavaScript中的 window。把元素利用$包装成jQuery对象，就可以调用jQuery 的方法。 1.2.5. jQuery 对象和 DOM 对象​ 使用 jQuery 方法和原生JS获取的元素是不一样的，总结如下 : 用原生 JS 获取来的对象就是 DOM 对象 jQuery 方法获取的元素就是 jQuery 对象。 jQuery 对象本质是： 利用$对DOM 对象包装后产生的对象（伪数组形式存储）。 注意： 只有 jQuery 对象才能使用 jQuery 方法，DOM 对象则使用原生的 JavaScirpt 方法。 1.2.6. jQuery 对象和 DOM 对象转换​ DOM 对象与 jQuery 对象之间是可以相互转换的。因为原生js 比 jQuery 更大，原生的一些属性和方法 jQuery没有给我们封装. 要想使用这些属性和方法需要把jQuery对象转换为DOM对象才能使用。 // 1.DOM对象转换成jQuery对象，方法只有一种 var box = document.getElementById(&#39;box&#39;); // 获取DOM对象 var jQueryObject = $(box); // 把DOM对象转换为 jQuery 对象 // 2.jQuery 对象转换为 DOM 对象有两种方法： // 2.1 jQuery对象[索引值] var domObject1 = $(&#39;div&#39;)[0] // 2.2 jQuery对象.get(索引值) var domObject2 = $(&#39;div&#39;).get(0) 总结：实际开发比较常用的是把DOM对象转换为jQuery对象，这样能够调用功能更加强大的jQuery中的方法。 1.3. jQuery 选择器​ 原生 JS 获取元素方式很多，很杂，而且兼容性情况不一致，因此 jQuery 给我们做了封装，使获取元素统一标准。 1.3.1. 基础选择器$(&quot;选择器&quot;) // 里面选择器直接写 CSS 选择器即可，但是要加引号 ​ 1.3.2. 层级选择器​ 层级选择器最常用的两个分别为：后代选择器和子代选择器。 ​ 基础选择器和层级选择器案例代码 &lt;body&gt; &lt;div&gt;我是div&lt;/div&gt; &lt;div class=&quot;nav&quot;&gt;我是nav div&lt;/div&gt; &lt;p&gt;我是p&lt;/p&gt; &lt;ul&gt; &lt;li&gt;我是ul 的&lt;/li&gt; &lt;li&gt;我是ul 的&lt;/li&gt; &lt;li&gt;我是ul 的&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $(function() { console.log($(&quot;.nav&quot;)); console.log($(&quot;ul li&quot;)); }) &lt;/script&gt; &lt;/body&gt; 1.3.3. 筛选选择器​ 筛选选择器，顾名思义就是在所有的选项中选择满足条件的进行筛选选择。常见如下 : 案例代码 &lt;body&gt; &lt;ul&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;li&gt;多个里面筛选几个&lt;/li&gt; &lt;/ol&gt; &lt;script&gt; $(function() { $(&quot;ul li:first&quot;).css(&quot;color&quot;, &quot;red&quot;); $(&quot;ul li:eq(2)&quot;).css(&quot;color&quot;, &quot;blue&quot;); $(&quot;ol li:odd&quot;).css(&quot;color&quot;, &quot;skyblue&quot;); $(&quot;ol li:even&quot;).css(&quot;color&quot;, &quot;pink&quot;); }) &lt;/script&gt; &lt;/body&gt; 另: jQuery中还有一些筛选方法，类似DOM中的通过一个节点找另外一个节点，父、子、兄以外有所加强。 偏重于记忆，演示代码略。 1.3.4 知识铺垫 jQuery 设置样式 $(&#39;div&#39;).css(&#39;属性&#39;, &#39;值&#39;) jQuery 里面的排他思想 // 想要多选一的效果，排他思想：当前元素设置样式，其余的兄弟元素清除样式。 $(this).css(“color”,”red”); $(this).siblings(). css(“color”,””); 隐式迭代 // 遍历内部 DOM 元素（伪数组形式存储）的过程就叫做隐式迭代。 // 简单理解：给匹配到的所有元素进行循环遍历，执行相应的方法，而不用我们再进行循环，简化我们的操作，方便我们调用。 $(&#39;div&#39;).hide(); // 页面中所有的div全部隐藏，不用循环操作 链式编程 // 链式编程是为了节省代码量，看起来更优雅。 $(this).css(&#39;color&#39;, &#39;red&#39;).sibling().css(&#39;color&#39;, &#39;&#39;); 1.4. jQuery 样式操作​ jQuery中常用的样式操作有两种：css() 和 设置类样式方法 1.4.1. 方法1: 操作 css 方法​ jQuery 可以使用 css 方法来修改简单元素样式； 也可以操作类，修改多个样式。 ​ 常用以下三种形式 : // 1.参数只写属性名，则是返回属性值 var strColor = $(this).css(&#39;color&#39;); // 2. 参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用跟单位和引号 $(this).css(&#39;&#39;color&#39;&#39;, &#39;&#39;red&#39;&#39;); // 3. 参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开， 属性可以不用加引号 $(this).css({ &quot;color&quot;:&quot;white&quot;,&quot;font-size&quot;:&quot;20px&quot;}); ​ 注意：css() 多用于样式少时操作，多了则不太方便。 1.4.2. 方法2: 设置类样式方法​ 作用等同于以前的 classList，可以操作类样式， 注意操作类里面的参数不要加点。 ​ 常用的三种设置类样式方法： // 1.添加类 $(&quot;div&quot;).addClass(&quot;current&quot;); // 2.删除类 $(&quot;div&quot;).removeClass(&quot;current&quot;); // 3.切换类 $(&quot;div&quot;).toggleClass(&quot;current&quot;); ​ 注意： 设置类样式方法比较适合样式多时操作，可以弥补css()的不足。 原生 JS 中 className 会覆盖元素原先里面的类名，jQuery 里面类操作只是对指定类进行操作，不影响原先的类名。 1.5. jQuery 效果​ jQuery 给我们封装了很多动画效果，最为常见的如下： 显示隐藏：show() / hide() / toggle() ; 划入画出：slideDown() / slideUp() / slideToggle() ; 淡入淡出：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ; 自定义动画：animate() ; 注意： 动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。 jQuery为我们提供另一个方法，可以停止动画排队：stop() ; 1.5.1. 显示隐藏​ 显示隐藏动画，常见有三个方法：show() / hide() / toggle() ; ​ 语法规范如下: 代码演示 &lt;body&gt; &lt;button&gt;显示&lt;/button&gt; &lt;button&gt;隐藏&lt;/button&gt; &lt;button&gt;切换&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { $(&quot;button&quot;).eq(0).click(function() { $(&quot;div&quot;).show(1000, function() { alert(1); }); }) $(&quot;button&quot;).eq(1).click(function() { $(&quot;div&quot;).hide(1000, function() { alert(1); }); }) $(&quot;button&quot;).eq(2).click(function() { $(&quot;div&quot;).toggle(1000); }) // 一般情况下，我们都不加参数直接显示隐藏就可以了 }); &lt;/script&gt; &lt;/body&gt; 1.5.2. 滑入滑出​ 滑入滑出动画，常见有三个方法：slideDown() / slideUp() / slideToggle() ; ​ 语法规范如下: 代码演示 &lt;body&gt; &lt;button&gt;下拉滑动&lt;/button&gt; &lt;button&gt;上拉滑动&lt;/button&gt; &lt;button&gt;切换滑动&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { $(&quot;button&quot;).eq(0).click(function() { // 下滑动 slideDown() $(&quot;div&quot;).slideDown(); }) $(&quot;button&quot;).eq(1).click(function() { // 上滑动 slideUp() $(&quot;div&quot;).slideUp(500); }) $(&quot;button&quot;).eq(2).click(function() { // 滑动切换 slideToggle() $(&quot;div&quot;).slideToggle(500); }); }); &lt;/script&gt; &lt;/body&gt; 小案例：下拉菜单略（详情参看源码）。 1.5.3 淡入淡出​ 淡入淡出动画，常见有四个方法：fadeIn() / fadeOut() / fadeToggle() / fadeTo() ; ​ 语法规范如下: 代码演示 &lt;body&gt; &lt;button&gt;淡入效果&lt;/button&gt; &lt;button&gt;淡出效果&lt;/button&gt; &lt;button&gt;淡入淡出切换&lt;/button&gt; &lt;button&gt;修改透明度&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { $(&quot;button&quot;).eq(0).click(function() { // 淡入 fadeIn() $(&quot;div&quot;).fadeIn(1000); }) $(&quot;button&quot;).eq(1).click(function() { // 淡出 fadeOut() $(&quot;div&quot;).fadeOut(1000); }) $(&quot;button&quot;).eq(2).click(function() { // 淡入淡出切换 fadeToggle() $(&quot;div&quot;).fadeToggle(1000); }); $(&quot;button&quot;).eq(3).click(function() { // 修改透明度 fadeTo() 这个速度和透明度要必须写 $(&quot;div&quot;).fadeTo(1000, 0.5); }); }); &lt;/script&gt; &lt;/body&gt; 1.5.4 自定义动画​ 自定义动画非常强大，通过参数的传递可以模拟以上所有动画，方法为：animate() ; ​ 语法规范如下: 代码演示 &lt;body&gt; &lt;button&gt;动起来&lt;/button&gt; &lt;div&gt;&lt;/div&gt; &lt;script&gt; $(function() { $(&quot;button&quot;).click(function() { $(&quot;div&quot;).animate({ left: 500, top: 300, opacity: .4, width: 500 }, 500); }) }) &lt;/script&gt; &lt;/body&gt; 1.5.5 停止动画排队​ 动画或者效果一旦触发就会执行，如果多次触发，就造成多个动画或者效果排队执行。 ​ 停止动画排队的方法为：stop() ; stop() 方法用于停止动画或效果。 stop() 写到动画或者效果的前面， 相当于停止结束上一次的动画。 ​ 总结: 每次使用动画之前，先调用 stop() ,在调用动画。 1.5.6. 事件切换​ jQuery中为我们添加了一个新事件 hover() ; 功能类似 css 中的伪类 :hover 。介绍如下 语法 hover([over,]out) // 其中over和out为两个函数 over:鼠标移到元素上要触发的函数（相当于mouseenter） out:鼠标移出元素要触发的函数（相当于mouseleave） 如果只写一个函数，则鼠标经过和离开都会触发它 hover事件和停止动画排列案例 &lt;body&gt; &lt;ul class=&quot;nav&quot;&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt; &lt;li&gt; &lt;a href=&quot;#&quot;&gt;微博&lt;/a&gt; &lt;ul&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;私信&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;评论&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;&quot;&gt;@我&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;script&gt; $(function() { // 鼠标经过 // $(&quot;.nav&gt;li&quot;).mouseover(function() { // // $(this) jQuery 当前元素 this不要加引号 // // show() 显示元素 hide() 隐藏元素 // $(this).children(&quot;ul&quot;).slideDown(200); // }); // // 鼠标离开 // $(&quot;.nav&gt;li&quot;).mouseout(function() { // $(this).children(&quot;ul&quot;).slideUp(200); // }); // 1. 事件切换 hover 就是鼠标经过和离开的复合写法 // $(&quot;.nav&gt;li&quot;).hover(function() { // $(this).children(&quot;ul&quot;).slideDown(200); // }, function() { // $(this).children(&quot;ul&quot;).slideUp(200); // }); // 2. 事件切换 hover 如果只写一个函数，那么鼠标经过和鼠标离开都会触发这个函数 $(&quot;.nav&gt;li&quot;).hover(function() { // stop 方法必须写到动画的前面 $(this).children(&quot;ul&quot;).stop().slideToggle(); }); }) &lt;/script&gt; &lt;/body&gt;","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}]},{"title":"排序","slug":"排序","date":"2020-05-20T14:39:00.000Z","updated":"2020-05-20T14:54:16.000Z","comments":true,"path":"排序/","link":"","permalink":"/排序/","excerpt":"","text":"1.选择排序（O(N^2)）//选择排序 public static int[] selectionSort(int[] in) { int lastIndex = in.length - 1; //即：循环遍历次数 for (int i = 0; i &lt;= lastIndex; i++) { //每次遍历，将最小元素浮动到最左边 //0~i是已排序序列，i~lastIndex是未排序序列，将未排序中的最小元素放在i位置 for(int j = i; j &lt;= lastIndex; j++) { //默认in[i]是最小元素，如果in[j]小于in[i]，则交换 if (in[j] &lt; in[i]) { //如果i=j，那么in[i]=in[j] //所以可以保证in[i]、in[j]是不同对象，可以通过异或进行交换 in[i] = in[i] ^ in[j]; in[j] = in[i] ^ in[j]; in[i] = in[i] ^ in[j]; } } } return in; } 2.冒泡排序（O(N^2)） //冒泡排序 public static int[] bubbleSort(int[] in) { int lastIndex = in.length - 1; for (int i = 0; i &lt;= lastIndex; i++) { //[lastIndex - i,lastIndex]是排好序的序列 //[0,lastIndex - i)是未排好序的序列 for(int j = 0; j &lt;= lastIndex - i - 1; j++) { //与选择排序不同，冒泡排序是两两相邻元素比较后交换 //将较大的交换到后面 if (in[j + 1] &lt; in[j]) { //不同元素异或交换 in[j + 1] = in[j] ^ in[j + 1]; in[j] = in[j] ^ in[j + 1]; in[j + 1] = in[j] ^ in[j + 1]; } } } return in; } 2.1冒泡排序优化//优化冒泡排序——加入交换标志位 public static int[] flagBubbleSort(int[] in) { //标志位：本趟排序是否进行了交换 //如果本趟排序没有进行元素交换，说明已经有序了，可以提前结束循环 boolean exchange; int lastIndex = in.length - 1; for (int i = 0; i &lt;= lastIndex; i++) { exchange = false; //[lastIndex - i,lastIndex]是排好序的序列 //[0,lastIndex - i)是未排好序的序列 for(int j = 0; j &lt;= lastIndex - i - 1; j++) { //与选择排序不同，冒泡排序是两两相邻元素比较后交换 //将较大的交换到后面 if (in[j + 1] &lt; in[j]) { //不同元素异或交换 in[j + 1] = in[j] ^ in[j + 1]; in[j] = in[j] ^ in[j + 1]; in[j + 1] = in[j] ^ in[j + 1]; exchange = true; //发生了交换 } } if(!exchange) break; //无交换直接退出循环 } return in; } 3.插入排序（O(N^2)） //插入排序 public static int[] insertionSort(int[] in) { int lastIndex = in.length - 1; //从1开始遍历，是默认最开始的已排序序列就是第一个元素，index=0 for (int i = 1; i &lt;= lastIndex; i++) { int temp = in[i]; //待比较元素 //注意i不能比1小，否则就会数组越界 while (i &gt;= 1 &amp;&amp; in[i - 1] &gt; temp) { //已排序序列[0,i)，最大下标i - 1 //i - 1位置元素大于待比较元素，i - 1位置元素后移 in[i] = in[i - 1]; i--; } //退出循环说明找到了合适的位置 in[i] = temp; } return in; } 3.1希尔排序（O(NlogN)）/缩小增量排序/希尔排序 public static int[] shellSort(int[] in) { int gap = in.length &gt;&gt; 1; //初始值，gap = len / 2 while (gap &gt; 0) { //从gap开始是因为默认[0,gap)是排好序的 //即每个子序列第一个元素是排好序的，一共gap个元素 //将序列分为gap组，对子序列进行插入排序 for (int i = gap; i &lt; in.length; i++) { int temp = in[i]; //限制了gap&gt;0，所以只需要 i-gap&gt;=0 而非 1 while ((i - gap &gt;= 0) &amp;&amp; (in[i - gap] &gt; temp) ) { in[i] = in[i - gap]; i -= gap; //每次跨度为一个gap } //退出循环说明找到了合适位置 in[i] = temp; } gap = gap &gt;&gt; 1; //gap = gap / 2 } return in; } 4.归并排序（O(NlogN)）合并 //合并两个有序子序列 //@params: left[] 左子序列 //@params: right[] 右子序列 public static void merge(int[] left, int[] right) { //结果序列，用于合并两个子有序序列 int[] rst = new int[left.length + right.length]; //左子序列、右子序列、总序列当前位置 int l = 0, r = 0, curr = 0; //遍历，直到某个子序列被遍历完，将较小的放前面 while (l &lt; left.length &amp;&amp; r &lt; right.length) { if (left[l] &lt; right[r]) { rst[curr] = left[l]; l++; curr++; }else{ rst[curr] = right[r]; r++; curr++; } } //剩余序列直接加入结果序列 while(l &lt; left.length) { rst[curr] = left[l]; l++; curr++; } while (r &lt; right.length) { rst[curr] = right[r]; r++; curr++; } return rst; } 归并 //归并排序：递归地使用二分法，将一个序列分解为两个子序列，直到子序列只剩下一个元素 //@params: in[] public static int[] mergeSort(int[] in) { //退出递归的条件：子序列只剩下一个元素 if(in == null || in.length &lt; 2) return in; int mid = in.length &gt;&gt; 1; //从中间将序列切分 //Arrays.copyOfRange(int[] a, int from, int to); 复制范围[from,to) int[] left = Arrays.copyOfRange(in, 0, mid); //不包括mid int[] right = Arrays.copyOfRange(in, mid, in.length); //递归调用mergeSort，然后将结果merge合并 return merge(mergeSort(left), mergeSort(right) ); } 测试 int[] in = {999, 1, 2, 4, 3, -1, 0, 0}; System.out.println(&quot;归并排序： &quot; + Arrays.toString(mergeSort(in))); //归并排序： [-1, 0, 0, 1, 2, 3, 4, 999] 5.快速排序（O(NlogN)）public static void quickSort(int[] in, int low, int high) { //退出递归条件：子序列只有一个元素，此时low = high if(low &gt; high) return; int pivot = in[low]; //基准值，选最左边元素 int quick = high; //快指针，比慢指针先走一步，从右往左 int slow = low; //慢指针，从左往右 //当quick遇到了比pivot小的元素， //同时slow遇到了比pivot大的元素，那么就交换两个元素 while (slow &lt; quick) { //快指针要先走一步 //快指针向左，直到找到比pivot小的元素 while (in[quick] &gt;= pivot &amp;&amp; slow &lt; quick) { quick--; } //慢指针往右，直到找到比pivot大的元素 while (in[slow] &lt;= pivot &amp;&amp; slow &lt; quick) { slow++; } //需要再次判断slow是否已经遇到或超过了quick if (slow &lt; quick) { //交换两个元素 —— 可以肯定slow!=quick，是不同元素， //所以可以用异或交换两个元素 in[slow] = in[slow] ^ in[quick]; in[quick] = in[slow] ^ in[quick]; in[slow] = in[slow] ^ in[quick]; } } //将快慢指针所在位置元素与基准值进行交换 //slow与quick相遇的位置，就是基准值指针应该在的位置 in[low] = in[slow]; in[slow] = pivot; //slow或者quick就是新的pivot，左边元素都比它小，右边元素都比它大 //递归对pivot的左右序列进行快排 quickSort(in, low, slow - 1); //基准值不需要再排序，所以是slow-1 quickSort(in, slow + 1, high); //基准值不需要再排序，所以是slow+1 } 测试 int[] in = {999, 1, 2, 4, 3, -1, 0, 0}; quickSort(in, 0, in.length - 1); System.out.println(Arrays.toString(in)); //结果为：[-1, 0, 0, 1, 2, 3, 4, 999] 6.堆排序（O(N + KlogN)，K是排序序列长度）//heapify：将满二叉树构建为堆 //@param: tree[] 表示堆的数组 //@param: n 节点总数 //@param: i 对哪个节点进行heapify public static void heapify(int[] tree, int n, int i) { if(i &gt;= n) return; //结束递归条件：建堆节点下标超过节点总数，i&gt;=n //根据满二叉树的特点，有： int left = 2 * i + 1; //左子树 int right = 2 * i + 2; //右子树 //将父亲、左右子树3者中最大的数替换到父亲节点 int max = i; //注意left 和 right不能越界 if(left &lt; n &amp;&amp; tree[left] &gt; tree[max]) max = left; if (right &lt; n &amp;&amp; tree[right] &gt; tree[max]) max = right; if(max != i) { //如果父亲节点就是最大节点，就不需要重新建堆了 //交换max和i的元素 tree[max] = tree[max] ^ tree[i]; tree[i] = tree[max] ^ tree[i]; tree[max] = tree[max] ^ tree[i]; //对替换下去的节点重新建堆 heapify(tree, n, max); } }","categories":[{"name":"数据结构","slug":"数据结构","permalink":"/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"/categories/数据结构/"}]},{"title":"http小结","slug":"http小结","date":"2020-05-19T03:00:00.000Z","updated":"2020-05-19T04:13:50.000Z","comments":true,"path":"http小结/","link":"","permalink":"/http小结/","excerpt":"","text":"http 1.0 HTTP 1.0中，每一个请求都要开一个连接，请求结束，断开连接。这样的协议有两个问题 （1）性能问题：每次请求都打开一个新的连接，因为连接数有限，而且连接的建立和断开都很耗时（可能一个页面就会有几十个请求）。 （2）服务器推送问题：服务器无法主动向客户端推送消息。 Keep-Alive机制 为了解决一个请求完成后连接立即断开的问题，引入了Keep-Alive（保持心跳）机制。客户端在HTTP请求头部加上一个字段Connection：Keep-Alive。服务器端收到带有这样的字段的请求后，会维护一个Keep-Alive timeout参数，服务器在处理完请求后，不会立即断开连接，而是会保持连接，如果在timeout时间内都没有新的请求，那么服务器才会关闭这个连接。 http 1.1 连接复用机制 HTTP 1.1将连接复用变成了默认的了，就算不设置字段Connection：Keep-Alive，请求完后也不会立即关闭连接。要想连接不复用，需要设置字段Connection：Close。 Pipeline和Head-of-line Blocking（队头阻塞）问题 为了让请求变为并发，引入了Pipeline机制，使得一个请求发出之后，在未收到响应之前，可以立即发送第二个请求。但是这里有个致命的问题，也就是Head-of-line Blocking（队头阻塞）问题。虽然Pipeline机制可以让请求并发，但是为了让请求和响应能配对，响应并不能并发。返回的响应需要按照先进先出的（类似队列）的顺序，所以如果第一个响应由于某些原因，会导致后面的响应会被阻塞。 服务器推送 客户端定期轮询：客户端每隔一段时间向服务器发送一个请求，如果服务器有消息就返回（效率较低，不建议）。WebSocket：这是一种基于TCP的可全双工通信的协议，可实现服务器主动推送。HTTP长轮询：保持一个HTTP长连接，如果服务器有新消息，就返回。如果在约定的时间还没有消息，服务器就返回一个空消息，然后客户端关闭该连接，再发起一个新的连接。 http 2 与HTTP 1.1兼容 由于HTTP 1.1的应用已成主流，所以想要替代它几乎不可能，所以只能向它兼容。其实HTTP/2与HTTP1.1并不是平级的，HTTP/2是介于HTTP1.1与TCP之间的一个转换层。 二进制分帧 为了解决队头阻塞的问题，HTTP/2将一个请求的报文转换成二进制并分成多个帧来进行传输。由于请求和响应都可以乱序的发送，所以需要给每个请求或响应带上一个ID，好让他们匹配。二进制分帧其实并没有完全解决队头阻塞的问题，它只是把这个问题转移到了TCP层面（只要使用TCP协议，为了保证可靠性，采用先进先出，就一定会有队头阻塞的问题）。如果想要彻底解决队头阻塞的问题，只能不使用TCP协议，那就是Google提出的QUIC协议。 请求和响应报文请求报文 响应报文 请求行 响应状态行 响应行： HTTP协议 状态码 状态码描述 头部 Host：Host 表示的是对象所在的主机 User-agent: 这是请求头用来告诉 Web 服务器，浏览器使用的类型是 Mozilla/4.0 Accept-language 告诉 Web 服务器，浏览器想要得到对象的语法版本，前提是服务器需要支持法语类型，否则将会发送服务器的默认版本 Date：Date 是一个通用标头，它可以出现在请求标头和响应标头中，表示的是格林威治标准时间，这个时间要比北京时间慢八个小时 Content-Length：实体报头指示实体主体的大小，以字节为单位，发送到接收方。 Content-Encoding：个实体报头用来压缩媒体类型。Content-Encoding 指示对实体应用了何种编码。常见的内容编码有这几种： gzip、compress、deflate、identity ，这个属性可以应用在请求报文和响应报文中 HTTP 请求 URL HTTP 协议使用 URI 定位互联网上的资源。正是因为 URI 的特定功能，在互联网上任意位置的资源都能访问到。URL 带有请求对象的标识符。在上面的例子中，浏览器正在请求对象 /somedir/page.html 的资源。 比如http://www.example.com:80/path/to/myfile.htmlkey1=value1&amp;key2=value2#SomewhereInTheDocument 这个 URL http://告诉浏览器使用何种协议。对于大部分 Web 资源，通常使用 HTTP 协议或其安全版本，HTTPS 协议。另外，浏览器也知道如何处理其他协议。 www.example.com 既是一个域名，也代表管理该域名的机构。它指示了需要向网络上的哪一台主机发起请求。当然，也可以直接向主机的 IP address 地址发起请求。但直接使用 IP 地址的场景并不常见。 我们前面说到，两个主机之间要发起 TCP 连接需要两个条件，主机 + 端口。它表示用于访问 Web 服务器上资源的入口。如果访问的该 Web 服务器使用HTTP协议的标准端口（HTTP为80，HTTPS为443）授予对其资源的访问权限，则通常省略此部分。否则端口就是 URI 必须的部分。 /path/to/myfile.html 是 Web 服务器上资源的路径。以端口后面的第一个 / 开始，到 ? 号之前结束，中间的 每一个/ 都代表了层级（上下级）关系。这个 URL 的请求资源是一个 html 页面。 ?key1=value1&amp;key2=value2 是提供给 Web 服务器的额外参数。如果是 GET 请求，一般带有请求 URL 参数，如果是 POST 请求，则不会在路径后面直接加参数。这些参数是用 &amp; 符号分隔的键/值对列表。key1 = value1 是第一对，key2 = value2 是第二对参数 #SomewhereInTheDocument 是资源本身的某一部分的一个锚点。锚点代表资源内的一种“书签”，它给予浏览器显示位于该“加书签”点的内容的指示。 例如，在HTML文档上，浏览器将滚动到定义锚点的那个点上；在视频或音频文档上，浏览器将转到锚点代表的那个时间。值得注意的是 # 号后面的部分，也称为片段标识符，永远不会与请求一起发送到服务器。 HTTP 优缺点HTTP 的优点 简单灵活易扩展HTTP 最重要也是最突出的优点是 简单、灵活、易于扩展。 HTTP 的协议比较简单，它的主要组成就是 header + body，头部信息也是简单的文本格式，而且 HTTP 的请求报文根据英文也能猜出来个大概的意思，降低学习门槛，能够让更多的人研究和开发 HTTP 应用。 所以，在简单的基础上，HTTP 协议又多了灵活 和 易扩展 的优点。 HTTP 协议里的请求方法、URI、状态码、原因短语、头字段等每一个核心组成要素都没有被制定死，允许开发者任意定制、扩充或解释，给予了浏览器和服务器最大程度的信任和自由。 应用广泛、环境成熟因为过于简单，普及，因此应用很广泛。因为 HTTP 协议本身不属于一种语言，它并不限定某种编程语言或者操作系统，所以天然具有跨语言、跨平台的优越性。而且，因为本身的简单特性很容易实现，所以几乎所有的编程语言都有 HTTP 调用库和外围的开发测试工具。 随着移动互联网的发展， HTTP 的触角已经延伸到了世界的每一个角落，从简单的 Web 页面到复杂的 JSON、XML 数据，从台式机上的浏览器到手机上的各种 APP、新闻、论坛、购物、手机游戏，你很难找到一个没有使用 HTTP 的地方。 无状态无状态其实既是优点又是缺点。因为服务器没有记忆能力，所以就不需要额外的资源来记录状态信息，不仅实现上会简单一些，而且还能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。 HTTP 的缺点 无状态既然服务器没有记忆能力，它就无法支持需要连续多个步骤的事务操作。每次都得问一遍身份信息，不仅麻烦，而且还增加了不必要的数据传输量。由此出现了 Cookie 技术。 明文HTTP 协议里还有一把优缺点一体的双刃剑，就是明文传输。明文意思就是协议里的报文（准确地说是 header 部分）不使用二进制数据，而是用简单可阅读的文本形式。 对比 TCP、UDP 这样的二进制协议，它的优点显而易见，不需要借助任何外部工具，用浏览器、Wireshark 或者 tcpdump 抓包后，直接用肉眼就可以很容易地查看或者修改，为我们的开发调试工作带来极大的便利。 当然缺点也是显而易见的，就是不安全，可以被监听和被窥探。因为无法判断通信双方的身份，不能判断报文是否被更改过。 性能HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"String.trim()理解","slug":"String-trim-理解","date":"2020-05-13T04:19:22.000Z","updated":"2020-05-13T04:37:14.000Z","comments":true,"path":"String-trim-理解/","link":"","permalink":"/String-trim-理解/","excerpt":"","text":"trim去掉的是什么字符？ 《Java核心技术》书上说的trim主要是是“返回一个新的字符串。这个字符串将删除了原始字符串头部和尾部的空格。” 但是，有些特殊字符是看不到的 public static void main(String[] args) { String str = &quot;abc\u001e\u001e\u001e\u001f\u001f\u001f&quot;; System.out.println(str.length()); str = str.trim(); System.out.println(str.length()); } 比如这段代码，输出的是9和3，但是在eclipse或者idea是看不到的，也就是说trim不只是排掉空格这么简单的作用 /** * @return A string whose value is this string, with any leading and trailing white * space removed, or this string if it has no leading or * trailing white space. */ public String trim() { int len = value.length; int st = 0; char[] val = value; /* avoid getfield opcode */ while ((st &lt; len) &amp;&amp; (val[st] &lt;= &#39; &#39;)) { st++; } while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= &#39; &#39;)) { len--; } return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this; } 可以知道，由于空格的Unicode编码是32，trim()方法实际上trim掉了字符串两端Unicode编码小于等于32（\\u0020）的所有字符。 trim返回的对象 public static void main(String[] args) { String str1 = &quot;abc &quot;; String str2 = &quot;abc&quot;; String str3 = &quot;abc&quot;; str1 = str1.trim(); System.out.println(str1 == str2); // false System.out.println(str3 == str2); // true } str1.trim()返回的字符串为”abc”，而在常量池中已经确定存在这个”abc”这个String对象，那为何str1==str2不成立呢？我们看trim()方法的最后一行： return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this; 也就是说，trim()方法实际上的行为并不是去掉两端的空白字符，而是截取中间的非空白字符 public String substring(int beginIndex, int endIndex) { if (beginIndex &lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } if (endIndex &gt; value.length) { throw new StringIndexOutOfBoundsException(endIndex); } int subLen = endIndex - beginIndex; if (subLen &lt; 0) { throw new StringIndexOutOfBoundsException(subLen); } return ((beginIndex == 0) &amp;&amp; (endIndex == value.length)) ? this : new String(value, beginIndex, subLen); } 当实际发生了”截取“这个动作的时候，因为此处无法直接声明一个String常量，即substring()无法像我们写String str = “abc”这样直接在常量池中创建对象，所以它返回的是一个new出来的对象，这个对象位于Heap内存中。","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"letcode58反转单词顺序","slug":"letcode58","date":"2020-05-13T04:03:00.000Z","updated":"2020-05-13T04:38:42.000Z","comments":true,"path":"letcode58/","link":"","permalink":"/letcode58/","excerpt":"","text":"输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student. “，则输出”student. a am I”。 双指针class Solution { public String reverseWords(String s) { //去空格 s=s.trim(); //可变字符串 StringBuilder res=new StringBuilder(); int j=s.length()-1; int i=j; while(i&gt;=0){ //找到完整的单词 while(i&gt;=0 &amp;&amp; s.charAt(i)!=&#39; &#39;) i--; res.append(s.substring(i+1,j+1)+&#39; &#39;); while(i&gt;=0 &amp;&amp; s.charAt(i)==&#39; &#39;) i--; j=i; } return res.toString().trim(); } } 倒序遍历字符串，遇到空格则停下，即一个单词，j充当边界 注意trim不是单纯的去掉空格，而是截取中间的非空白字符串，返回的是一个new出来的对象，这就联系到substring的源码，我的另一篇博客有写","categories":[{"name":"数据结构","slug":"数据结构","permalink":"/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"/categories/数据结构/"}]},{"title":"Letcode57 滑动窗口","slug":"滑动窗口","date":"2020-05-13T03:01:00.000Z","updated":"2020-05-13T03:15:18.000Z","comments":true,"path":"滑动窗口/","link":"","permalink":"/滑动窗口/","excerpt":"","text":"和为S的连续正数序列 输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 代码class Solution { public int[][] findContinuousSequence(int target) { int i=1; int j=1; int sum=0; List&lt;int[]&gt; res =new ArrayList&lt;&gt;(); while(i&lt;=target/2){ if(sum&lt;target){ sum+=j; j++; }else if(sum&gt;target){ sum-=i; i++; }else{ int []arr=new int[j-i]; for(int a=i;a&lt;j;a++){ arr[a-i]=a; } res.add(arr); sum-=i; i++; } } return res.toArray(new int[res.size()][]); } } 思路的话首先是确认两端，左闭右开 当窗口中的sum小于target时，证明右端j要往右移动，由于是开区间，sum需要+j，然后再移动j 当窗口中的sum大于target时，则左端i要往右移动，因为是闭区间，sum需要先-i，然后再移动i 当窗口大小sum等于target时，把窗口中的数字放入数组，继续右移i 循环终止的条件是i&lt;=target/2，因为是连续的正数序列，如果i比target的一半大的话，那窗口则不存在了，因为一定会大于target","categories":[{"name":"数据结构","slug":"数据结构","permalink":"/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"/categories/数据结构/"}]},{"title":"mysql错误代码2003的解决办法","slug":"mysql错误代码2003的解决办法","date":"2020-05-12T04:12:00.000Z","updated":"2020-05-12T04:30:38.000Z","comments":true,"path":"mysql错误代码2003的解决办法/","link":"","permalink":"/mysql错误代码2003的解决办法/","excerpt":"","text":"启动即可 除此之外我还遇到一个问题 idea连接数据库的时候报错 Server returns invalid timezone. Go to ‘Advanced’ tab and set ‘serverTimezon 一般是时区的问题 进入命令窗口（Win + R），连接数据库 mysql -hlocalhost -uroot -p，回车，输入密码，回车， 输入set global time_zone = ‘+8:00’; 回车","categories":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}],"tags":[],"keywords":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}]},{"title":"树的按层遍历","slug":"树的按层遍历","date":"2020-05-12T04:07:00.000Z","updated":"2020-05-12T04:31:24.000Z","comments":true,"path":"树的按层遍历/","link":"","permalink":"/树的按层遍历/","excerpt":"","text":"从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。即从左到右按层放入数组 Java中List, Integer, int的相互转换 上面的升级版，每层放进一个数组 Z字输出","categories":[{"name":"数据结构","slug":"数据结构","permalink":"/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"/categories/数据结构/"}]},{"title":"JVM中new一个对象","slug":"JVM中new一个对象","date":"2020-05-12T04:04:00.000Z","updated":"2020-05-12T04:24:46.000Z","comments":true,"path":"JVM中new一个对象/","link":"","permalink":"/JVM中new一个对象/","excerpt":"","text":"当虚拟机遇到new指令的时候 检查、确认内存大小和分配内存、初始化内存空间 1.检查指令的参数能否在常量池中定位到一个类的符合引用，并且检查这个符号引用代表的类有没有被加载、解析和初始化过 2.如果没有，则执行类加载过程 3类加载检查通过后，便可以确认对象所需的内存大小，如何进行分配内存 4.指针碰撞：可以理解为一边是使用的内存一边是空的，夹在中间的指针，分配内存的时候就是指针往空的内存挪一丢丢距离，即和对象所需内存大小一样的内存空间。 高效简单！ 5.空闲列表：就是内存不够整齐，坑坑洼洼的，得专门记录哪块内存可用，分配时找到大的内存空间给对象。比较复杂！ 6.如果是使用复制算法和标记压缩法 使用指针碰撞 如果是使用标记清除算法，则使用空闲列表 7.分到内存后要将分配到的内存空间都初始化为0，不包含对象头（不知道为什么，日后研究） 8.设置对象，将一些信息存放到对象头（哪个类的实例，如何找到类的元数据信息，hash码，GC分代年龄）。到这一步对象就产生了！ 对象的内存布局 1.对象头（两部分） Mark World：存放运行时数据（hashcoad，GC分代年龄，锁的状态标志，线程持有的锁） 类型指针：对象指向它的类型元数据指针 2.实例数据 3.对齐填充：占位符作用 对象的访问定位： 通过栈的reference 1.句柄访问：Java堆中专门划分内存当作句柄池，reference存储的是对象的句柄地址 好处：储存的是稳定的句柄地址，GC时候对象位置发生变化只需要修改句柄中的实例数据指针 2.直接指针访问：referenc直接存储的是对象地址，速度较快","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}]},{"title":"JVM体系结构","slug":"JVM体系结构","date":"2020-05-12T04:00:00.000Z","updated":"2020-05-12T04:23:48.000Z","comments":true,"path":"JVM体系结构/","link":"","permalink":"/JVM体系结构/","excerpt":"","text":"程序计数器： 比较小的内存空间，可以看成是当前线程所执行的字节码的行号指示器 字节码解释器工作时就是通过改变它的值来选取下一条需要执行的字节码指令 为什么每个线程都要有一个独立的程序计数器？ 因为任何一个确定的时刻，一个处理器只会执行一条线程中的指令，线程会一直切换，为了让线程切换后能恢复正确的执行位置 Java虚拟机栈： 每个方法被执行的时候，虚拟据会同步创建一个栈帧放到虚拟机栈中，调用入栈，执行完毕出栈 栈帧又包含了：局部变量表，方法出口，操作数栈，动态连接（后面两个什么鬼）等信息 局部变量表：八大基本数据类型以及对象引用reference 本地方法栈和虚拟机栈的区别：虚拟机栈是为虚拟机执行Java方法的（字节码服务）本地方法栈则是为虚拟机使用到的本地方法服务Native！native：java的作用范围达不到，会去调用底层的C语音的库通过JNI调用本地方法接口 JNI的作用：融合不同的语言让java为所欲为 本地方法区： 用于存储以及被虚拟机加载的类信息，常量，静态变量（貌似有个常量池） 以前是用永久代实现方法区，所以很多人觉得永久代等于方法区 1.6常量池在方法区中，1.7常量池在堆中，1.8常量池在元空间（方法区）中 Java堆： 所有的对象实例和数组都是在里面分配内存，也称GC堆，分为元空间，Eden，Old","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}]},{"title":"垃圾回收","slug":"垃圾回收","date":"2020-05-12T03:49:00.000Z","updated":"2020-05-12T04:22:30.000Z","comments":true,"path":"垃圾回收/","link":"","permalink":"/垃圾回收/","excerpt":"","text":"如何识别垃圾？ 引用计数法：对象每被引用一次，就在该对象的对象头加上一次引用次数，如果引用次数为0，则此对象可以回收 可达性算法：以GC Root的对象为起点，如果相关对象不在任意一个以GC Root为起点的引用链中，则会被回收。 发生GC的时候，会先判断对象是否执行了finalize方法，如果没有则先执行finalize方法，（在这个方法中对象还有一次逃出死亡的机会，如果跟GC Root关联起来就不会被清理）执行finalize方法之后，再判断对象是否可达，不可达则回收。finalize方法只会被执行一次，也就是只有一次机会，以后再被GC会直接回收，不再进入finalize。 GC Root有哪几类？ 虚拟机栈中引用的对象 本地方法栈INJ引用的对象 方法区中类静态属性引用的对象 方法区中常量应用的对象 垃圾回收的方法：标记清除法，复制算法，标记整理法， 对象晋生老年代： 1.次数超过15（默认） 2.大对象，减少开销 3.在S区中相同年龄的对象大小之和大于空间一半以上，则年龄大于该年龄的对象也会晋升到老年代 Stop The World GC的时候会触发STW，只有垃圾回收器线程在工作，其他工作线程被挂起。 Full GC导致的STW会更长，所以要尽可能避免对象过早进入老年去，尽可能晚的触发FullGC 新生代和老年代空间大小1：2也是这个原因 因为Full GC影响性能，一般要选择合适的时机进行，也就是safa Point safe Point：循环的末尾 方法返回前 调用方法的call之后 抛出异常的位置 垃圾收集器种类 新生代：Serial ParNew Parallel Scavenge 老年代：Serial Old CMS Parallel Old 通吃：G1 Serial：单线程的垃圾回收器 ParNew：上面的多线程版本（复制算法）减少了STW的时间，只有它能和CMS收集器配合工作 Parallel Scavenge：和上面的差不多，能控制最大垃圾回收时间参数和直接设置吞吐量大小 Serial Old：工作在老年区的单线程的垃圾回收器 Parallel Old：多线程，也是吞吐量优先 CMS：以实现最短STW为目标的收集器，并发收集器，垃圾收集器线程和用户线程同时工作 采用标记清除法有四个步骤： 初始标记：（STW）只标记GC Root关联的对象 并发标记：GC Root Tracing，找出不可达的对象 重新标记 ：（STW）修正并发标记中有一些重新被引用了的对象 并发清除： CMS三个缺点： 1.吞吐量比较低 2.无法处理浮动垃圾，清理的同时有新的垃圾产生，得等到下一次GC，也就是得留下足够的空间确保线程正常运行 3.标记清除法，大量内存碎片 G1： 1.和CMS一样，并发收集器 2.整理控件空间更 3.不会牺牲大量的吞吐性能 4.不需要更大java 堆空间 5.需要GC停顿时间更好预测 对比CMS： 1.不会产生内存碎片，G1从整体上看是标记整理法，局部上是复制算法，都不会产生内存碎片 2.可以设定停顿时间 G1各代的存储地址不是连续的，每一代都使用了n个不连续的大小相同的Region，除了新老生代，还有个H区，放大对象，防止反复拷贝移动。 可以根据价值大小维护一个优先列表，优先收集回收价值的Region，避免了整个老年代的回收，减少了STW 初始标记，并发标记，最终标记，筛选回收","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}]},{"title":"主从复制","slug":"主从复制","date":"2020-05-12T03:37:00.000Z","updated":"2020-05-12T04:29:44.000Z","comments":true,"path":"主从复制/","link":"","permalink":"/主从复制/","excerpt":"","text":"什么是主从复制? 主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库，主数据库一般是准实时的业务数据库。您看，像在mysql数据库中，支持单项、异步赋值。在赋值过程中，一个服务器充当主服务器，而另外一台服务器充当从服务器。此时主服务器会将更新信息写入到一个特定的二进制文件中。并会维护文件的一个索引用来跟踪日志循环。这个日志可以记录并发送到从服务器的更新中去。当一台从服务器连接到主服务器时，从服务器会通知主服务器从服务器的日志文件中读取最后一次成功更新的位置。然后从服务器会接收从哪个时刻起发生的任何更新，然后锁住并等到主服务器通知新的更新 主从复制的作用（好处，或者说为什么要做主从）重点？ 做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。 架构的扩展。业务量越来越大,I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的评率，提高单个机器的I/O性能。 读写分离，使数据库能支持更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。 1在从服务器可以执行查询工作(即我们常说的读功能)，降低主服务器压力;（主库写，从库读，降压） 2在从主服务器进行备份，避免备份期间影响主服务器服务;（确保数据安全） 3当主服务器出现问题时，可以切换到从服务器。（提升性能） 主从复制的原理？ 1.数据库有个bin-log二进制文件，记录了所有sql语句。 2.我们的目标就是把主数据库的bin-log文件的sql语句复制过来。 3.让其在从数据的relay-log重做日志文件中再执行一次这些sql语句即可。 4.下面的主从配置就是围绕这个原理配置 5.具体需要三个线程来操作： a.binlog输出线程:每当有从库连接到主库的时候，主库都会创建一个线程然后发送binlog内容到从库。在从库里，当复制开始的时候，从库就会创建两个线程进行处理： b.从库I/O线程:当START SLAVE语句在从库开始执行之后，从库创建一个I/O线程，该线程连接到主库并请求主库发送binlog里面的更新记录到从库上。从库I/O线程读取主库的binlog输出线程发送的更新并拷贝这些更新到本地文件，其中包括relay log文件。 c.从库的SQL线程:从库创建一个SQL线程，这个线程读取从库I/O线程写到relay log的更新事件并执行。 可以知道，对于每一个主从复制的连接，都有三个线程。拥有多个从库的主库为每一个连接到主库的从库创建一个binlog输出线程，每一个从库都有它自己的I/O线程和SQL线程。 主从复制如图 帮助理解： 主从复制的好处？ 做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。 架构的扩展。业务量越来越大,I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的评率，提高单个机器的I/O性能。 读写分离，使数据库能支持更大的并发。在报表中尤其重要。由于部分报表sql语句非常的慢，导致锁表，影响前台服务。如果前台使用master，报表使用slave，那么报表sql将不会造成前台锁，保证了前台速度。 好处一:实现服务器负载均衡 通过服务器复制功能，可以在主服务器和从服务器之间实现负载均衡。即可以通过在主服务器和从服务器之间切分处理客户查询的负荷，从而得到更好地客户相应时间。通常情况下，数据库管理员会有两种思路。 一是在主服务器上只实现数据的更新操作。包括数据记录的更新、删除、新建等等作业。而不关心数据的查询作业。数据库管理员将数据的查询请求全部 转发到从服务器中。这在某些应用中会比较有用。如某些应用，像基金净值预测的网站。其数据的更新都是有管理员更新的，即更新的用户比较少。而查询的用户数 量会非常的多。此时就可以设置一台主服务器，专门用来数据的更新。同时设置多台从服务器，用来负责用户信息的查询。将数据更新与查询分别放在不同的服务器 上进行，即可以提高数据的安全性，同时也缩短应用程序的响应时间、提高系统的性能。 二是在主服务器上与从服务器切分查询的作业。在这种思路下，主服务器不单单要完成数据的更新、删除、插入等作业，同时也需要负担一部分查询作 业。而从服务器的话，只负责数据的查询。当主服务器比较忙时，部分查询请求会自动发送到从服务器重，以降低主服务器的工作负荷。当然，像修改数据、插入数 据、删除数据等语句仍然会发送到主服务器中，以便主服务器和从服务器数据的同步。 好处二：通过复制实现数据的异地备份 可以定期的将数据从主服务器上复制到从服务器上，这无疑是先了数据的异地备份。在传统的备份体制下，是将数据备份在本地。此时备份 作业与数据库服务器运行在同一台设备上，当备份作业运行时就会影响到服务器的正常运行。有时候会明显的降低服务器的性能。同时，将备份数据存放在本地，也 不是很安全。如硬盘因为电压等原因被损坏或者服务器被失窃，此时由于备份文件仍然存放在硬盘上，数据库管理员无法使用备份文件来恢复数据。这显然会给企业 带来比较大的损失。 而如果使用复制来实现对数据的备份，就可以在从服务器上对数据进行备份。此时不仅不会干扰主服务气的正常运行，而且在备份过程中主服务器可以继 续处理相关的更新作业。同时在数据复制的同时，也实现了对数据的异地备份。除非主服务器和从服务器的两块硬盘同时损坏了，否则的话数据库管理员就可以在最 短时间内恢复数据，减少企业的由此带来的损失。 好处三：提高数据库系统的可用性 数据库复制功能实现了主服务器与从服务器之间数据的同步，增加了数据库系统的可用性。当主服务器出现问题时，数据库管理员可以马上让从服务器作为主服务器，用来数据的更新与查询服务。然后回过头来再仔细的检查主服务器的问题。此时一般数据库管理员也会采用两种手段。 一是主服务器故障之后，虽然从服务器取代了主服务器的位置，但是对于主服务器可以采取的操作仍然做了一些限制。如仍然只能够进行数据的查询，而 不能够进行数据的更新、删除等操作。这主要是从数据的安全性考虑。如现在一些银行系统的升级，在升级的过程中，只能够查询余额而不能够取钱。这是同样的道理。 二是从服务器真正变成了主服务器。当从服务器切换为主服务器之后，其地位完全与原先的主服务器相同。此时可以实现对数据的查询、更新、删除等操 作。为此就需要做好数据的安全性工作。即数据的安全策略，要与原先的主服务器完全相同。否则的话，就可能会留下一定的安全隐患。 从数据库的读的延迟问题了解吗？如何解决？ 主库宕机后，数据可能丢失 从库只有一个sql Thread，主库写压力大，复制很可能延时 解决方法： 半同步复制—解决数据丢失的问题 并行复制—-解决从库复制延迟的问题 https://blog.csdn.net/darkangel1228/article/details/80003967 主从复制和主主复制区别？ 最大区别是 主从是对主操作数据，从会实时同步数据。反之对从操作，主不会同步数据，还有可能造成数据紊乱，导致主从失效。 主主则是无论对那一台操作，另一个都会同步数据。一般用作高容灾方案","categories":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}],"tags":[],"keywords":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}]},{"title":"MySQL中的锁","slug":"MySQL中的锁","date":"2020-05-12T03:28:00.000Z","updated":"2020-05-12T04:28:42.000Z","comments":true,"path":"MySQL中的锁/","link":"","permalink":"/MySQL中的锁/","excerpt":"","text":"事务及其ACID属性： 事务是由一组sql语句组成的逻辑处理单元，具有4个属性 原子性：事务是一个原子操作单元，其对数据的修改，要么都执行，要么都不执行 一致性：事务开始和完成的时候，数据都必须保持一致。事物的修改必须保持数据的完整性，事务结束后所有的内部数据结构（B+树，双向链表）多必须是正确的 隔离性：数据库系统提供一定的隔离机制，保证事务在不受外界并发操作影响的环境中执行。意味着事务处理过程中的中间状态对外部是不可见的 持久性：事务完成之后，对数据的修改是永久性的 并发事务处理带来的问题： 更新丢失：两个或多个事务同时选择一行并更新该行的数据，最后的更新覆盖了由其他事务做的更新。 脏读：一个事务正在对一条记录进行修改，在这个事务提交之前，其他事务过来了读取了脏数据并进一步做了处理，就会产生未提交的数据依赖关系。 不可重复读：一个数据在读取某些数据后的某个时间，再次读取以前读过的数据，会发现其读出的数据发生了变化或者被删除 幻读：一个事务按相同的查询条件重新读取以前检索过的数据，发现其他事务插入了满足其查询条件的新数据 事务隔离级别： 更新丢失问题通常是应该完全避免的，并不能只靠数据库的事务控制器解决，需要应用程序对要更新的数据加必要的锁来解决，防止更新丢失是应用的责任 脏读，不可重复读，幻读属于数据库读一致性问题，必须由数据库提供一定的事务隔离机制解决 1.在读取数据前加锁 2.不加锁，通过数据多版本并发控制 四种事务隔离级别： 锁 表锁：开销小，加锁快，不会出现死锁，并发度低，容易锁冲突 行锁：开销大，加锁慢，会出现死锁，并发度高，不容易锁冲突 InnoDB使用两种类型的行锁： 共享锁S（锁的是行）：称为读锁，就是说事务1对数据A加了S锁，事务1只能读不能修改A，其他事务也一样只能读不能写，只能加S锁不能加X锁，除非事务1释放S锁 排他锁X（du’de锁的是行）：称为写锁，事务1对数据加了X锁，能读能写，其他事务不能读和写，不能加任何锁 意向共享锁IS（锁的是表）：通知数据库要加什么表并对表进行加锁，如果需要对A进行加共享锁，先对该表加意向共享锁后再对A加共享锁 意向排他锁IX（锁的是表）：同上 意向共享锁和意向排他锁都是由数据库加的 InnoDB行锁是通过给索引加锁来实现的，只有通过索引条件检索数据才是使用行锁，否则使用表锁 间隙锁： 当我们用范围t条件而不是相等条件检索数据时，并请求了共享锁或者排他锁，InnoDB会给符合条件的已有数据记录的索引项加锁，对于在范围但是不存在的记录，会加间隙锁 目的：防止幻读，满足相关隔离级别的要求。因为有可能在读的过程其他事务插入了新的数据，就会产生幻读。 但这会造成严重的锁等待，因此要尽量使用相等条件来访问更新数据，避免使用范围条件 什么时候使用表锁： 对于InnoDB表，在绝大部分情况下都应该使用行级锁，因为事务和行锁往往是我们之所以选择InnoDB表的理由。但在个别特殊事务中，也可以考虑使用表级锁。 第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。 第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。 当然，应用中这两种事务不能太多，否则，就应该考虑使用MyISAM表了。 避免死锁的方法： （1）在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会。 （2）在程序以批量方式处理数据的时候，如果事先对数据排序，保证每个线程按固定的顺序来处理记录，也可以大大降低出现死锁的可能。 （3）在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁，更新时再申请排他锁，因为当用户申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁。","categories":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}],"tags":[],"keywords":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}]},{"title":"InnoDB和MyISAM的区别","slug":"InnoDB和MyISAM的区别","date":"2020-05-12T03:21:00.000Z","updated":"2020-05-12T04:27:34.000Z","comments":true,"path":"InnoDB和MyISAM的区别/","link":"","permalink":"/InnoDB和MyISAM的区别/","excerpt":"","text":"1：InnoDB支持事务，而MyISAM不支持，因此MyISAM的查询效率比InnoDB高 解决方法：可以取消自动提交事务功能 多条sql放在begin和commit之间组成一个事务 2：虽然多是B+树的结构，但是实现方式不同 InnoDB是聚集索引，MyISAM是非聚集索引 通过聚集索引可以查到需要的数据，而非聚集索引可以先查到对应的主键，再使用主键的值通过聚集索引定位到数据，总之，聚集索引是通往真实数据的唯一途径 3：InnoDB要求必须有主键，如果没有定义主键，那么该表的第一个唯一非空索引做为聚集索引 如果全都没有，innodb内部会生成一个隐藏的主键作为聚集索引，且这个主键会自增，6字节 4：InnoDB支持行锁，MyISAM支持表锁 行锁必须要有索引才能实现，否则会自动锁全表 5：如何选择？ a.支持事务选择InnoDB b.增删改频繁InnoDB c.读多写少选MyISAM 6：InnoDB四大特性 a.插入缓冲：提升插入性能 条件：非聚类索引，非唯一索引 先判断插入的非聚类索引页是否在缓冲池中，在就直接插入 不在就先放到Insert Buffer，按照一定的频率进行合并，写回disk，目的是为了减少随机IO带来的性能损耗 b.二次写 c.自适应哈希索引 d.预读 使用两种预读算法提高I/O的性能：线性预读和随机预读 7：为什么InnoDB推荐使用自增ID作为主键？ 保证每次插入时B+树索引是从右边扩展的，避免B+树频繁合并和分裂，否则会使得数据随即插入，效率比较差 8：MyISAM支持查询和插入操作的并发进行 通过设置concurrent-insert","categories":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}],"tags":[],"keywords":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}]},{"title":"索引","slug":"索引","date":"2020-05-12T03:02:00.000Z","updated":"2020-05-12T04:26:44.000Z","comments":true,"path":"索引/","link":"","permalink":"/索引/","excerpt":"","text":"索引是什么? 索引是一种帮助MySql高效获取数据的一种数据结构（B+Tree索引和Hash索引），一般默认是B+树 优点 : 1.提高查询效率，降低IO使用率 2.降低CPU的使用率（B树本身就是一个排序好的结构，排序的时候直接使用） 缺点： 1.本身占用内存，一般存在于硬盘 2.降低增删改的效率 索引快的原因 因为用的是B+树，查找的时候通过索引列表迅速定位到数据存放的位置 索引选择的原则？ 原则 1.占用存储空间少以及存储空间固定的字段 2.经常使用的字段，如where子句中的 3.更新频繁的字段不适合做索引 4.最左前缀原则 最左前缀原则？ mysql联合索引的时候，最左优先。如果是abc三列索引，则a，ab，abc都能建立索引，否则会索引失效 索引覆盖： 不读取源文件，只从索引文件中获取数据（不需要回表查询）using index 索引的优化： 1.根据sql解析的顺序，调整索引的顺序 2.范围查询in有时候会导致索引失效，可以交换索引顺序，把in放在最后面 3.最佳左前缀，保证顺序一致性 4.小表驱动大表 5.建立在经常使用的字段 优化sql的方法： 1.exist和in（联表查询中）：如果主查询的数据集大，用in,如果子查询的数据集大，用exist 2.order by的优化：双路排序和单路排序 索引的失效： 1.复合索引没有按照最左前缀原则 2.在索引上进行操作（计算，函数，类型转换） 3.复合索引不能使用！= &lt;&gt;或者is null，否则会失效 4.like尽量以常量开头，%开头会导致索引失效 5.类型转换会导致索引失效 6.使用or 慢查询优化思路： 1.开启慢查询日志功能，把慢sql找出来 2.选用合适的字段类型做索引，节省空间 3.子查询的exist和in 4.使用join代替子查询：这样就不用创建临时表了，但是也不是很高效,可以对关联查询进行分解， 就是对每个表进行一次单表查询，把查询结果关联起来 5.不用select * 6. 给where子句和order by子句涉及到的列创建索引 7.保证最左前缀原则","categories":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}],"tags":[],"keywords":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}]},{"title":"内部类","slug":"内部类","date":"2020-05-12T02:45:00.000Z","updated":"2020-05-12T02:58:58.000Z","comments":true,"path":"内部类/","link":"","permalink":"/内部类/","excerpt":"","text":"什么是内部类？ 定义在其它类内部中的类叫做内部类。 内部类成员可以直接访问外部类的私有数据，因为内部类是外部类的成员。 编译过后会生成两个或者多个class文件（取决于内部类的数量，中间用￥符号隔开） 内部类分为?（成员内部类）非静态内部类，静态内部类：算是类成员 局部内部类，匿名内部类。 非静态内部类： 1.在其内部方法找一个变量，会先在该方法找，再去内部类找，最后再去外部类找 2.不允许外部类的静态成员调用非静态内部类，常识 3.非静态内部类中不能定义静态成员 4.非静态内部类普通初始化块的作用与外部类完全相同 静态内部类： 1.这个内部类属于外部类本身，不属于外部类的对象 2.可以包含静态成员和非静态成员 3.外部类的上一级是包，所以不能用static修饰，内部类的上一级是外部类，用static修饰成为外部类相关 局部内部类： 把一个内部类放在方法内定义，就是局部内部类。不能用访问控制符和static 修饰。 匿名内部类： 只需要使用一次的类。","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}]},{"title":"配置","slug":"配置","date":"2020-05-11T12:39:00.000Z","updated":"2020-05-12T04:18:02.000Z","comments":true,"path":"配置/","link":"","permalink":"/配置/","excerpt":"","text":"mybatis-config.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;package name=&quot;com.fhl.pojo&quot;/&gt; &lt;mapper class=&quot;com.fhl.dao.BookMapper&quot;/&gt; &lt;/configuration database.propertiesjdbc.driver=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/ssmbuild?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8 jdbc.username=root jdbc.password=123456 spring-dao.xml 整合mybatis以及连接数据库&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 配置整合mybatis --&gt; &lt;!-- 1.关联数据库文件 --&gt; &lt;context:property-placeholder location=&quot;classpath:database.properties&quot;/&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;!--数据库连接池 dbcp 半自动化操作 不能自动连接 c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面） --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;30&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;10&quot;/&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;false&quot;/&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;10000&quot;/&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;2&quot;/&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:mybatis-config.xml&quot;/&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt; &lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.fhl.dao&quot;/&gt; &lt;/beans&gt; spring-service.xml spring注入相关&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 扫描service相关的bean --&gt; &lt;context:component-scan base-package=&quot;com.fhl.service&quot; /&gt; &lt;!--BookServiceImpl注入到IOC容器中--&gt; &lt;bean id=&quot;BookServiceImpl&quot; class=&quot;com.fhl.service.BookServiceImpl&quot;&gt; &lt;property name=&quot;bookMapper&quot; ref=&quot;bookMapper&quot;/&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/beans&gt; web.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;servlet-name&gt;DispatcherServlet &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet &lt;param-name&gt;contextConfigLocation &lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt; &lt;param-value&gt;classpath:applicationContext.xml &lt;load-on-startup&gt;1 &lt;servlet-name&gt;DispatcherServlet &lt;url-pattern&gt;/ &lt;filter-name&gt;encodingFilter org.springframework.web.filter.CharacterEncodingFilter &lt;param-name&gt;encoding &lt;param-value&gt;utf-8 &lt;filter-name&gt;encodingFilter &lt;url-pattern&gt;/* &lt;!--Session过期时间--&gt; &lt;session-timeout&gt;15 &lt;/web-app&gt; spring-mvc.xml：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 配置SpringMVC --&gt; &lt;!-- 1.开启SpringMVC注解驱动 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 2.静态资源默认servlet配置--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt; &lt;!-- 4.扫描web相关的bean --&gt; &lt;context:component-scan base-package=&quot;com.fhl.controller&quot; /&gt; &lt;/beans&gt; applicationContext.xml 最后把三个spring相关导入里面 整合到一起&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;import resource=&quot;spring-dao.xml&quot;/&gt; &lt;import resource=&quot;spring-service.xml&quot;/&gt; &lt;import resource=&quot;spring-mvc.xml&quot;/&gt; &lt;/beans&gt;","categories":[{"name":"配置","slug":"配置","permalink":"/categories/配置/"}],"tags":[],"keywords":[{"name":"配置","slug":"配置","permalink":"/categories/配置/"}]},{"title":"数据结构","slug":"数据结构","date":"2020-05-11T12:38:43.000Z","updated":"2020-05-11T12:44:44.000Z","comments":true,"path":"数据结构/","link":"","permalink":"/数据结构/","excerpt":"","text":"秃头的数据结构","categories":[{"name":"数据结构","slug":"数据结构","permalink":"/categories/数据结构/"}],"tags":[],"keywords":[{"name":"数据结构","slug":"数据结构","permalink":"/categories/数据结构/"}]},{"title":"java","slug":"java","date":"2020-05-11T12:37:25.000Z","updated":"2020-05-11T12:38:00.000Z","comments":true,"path":"java/","link":"","permalink":"/java/","excerpt":"","text":"java是最好的语言","categories":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}],"tags":[],"keywords":[{"name":"Java","slug":"Java","permalink":"/categories/Java/"}]},{"title":"测试背景图","slug":"测试背景图","date":"2020-05-11T05:34:59.000Z","updated":"2020-05-11T12:46:20.000Z","comments":true,"path":"测试背景图/","link":"","permalink":"/测试背景图/","excerpt":"","text":"真让人无语呀","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]},{"title":"测试类博客","slug":"测试类博客","date":"2020-05-11T05:00:54.000Z","updated":"2020-05-11T12:57:32.000Z","comments":true,"path":"测试类博客/","link":"","permalink":"/测试类博客/","excerpt":"","text":"QAQ测试哦","categories":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}],"tags":[],"keywords":[{"name":"数据库","slug":"数据库","permalink":"/categories/数据库/"}]},{"title":"HelloWorld","slug":"helloworld","date":"2020-05-05T14:06:17.000Z","updated":"2020-07-24T03:06:01.662Z","comments":true,"path":"helloworld/","link":"","permalink":"/helloworld/","excerpt":"","text":"helloHexo","categories":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}],"tags":[],"keywords":[{"name":"技术","slug":"技术","permalink":"/categories/技术/"}]}]}